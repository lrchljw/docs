"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4901],{4476:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>l,toc:()=>o});var r=i(4848),t=i(8453);const s={title:"Graph"},d=void 0,l={id:"algorithm/graph",title:"Graph",description:"- Tree: N nodes, N-1 edges, fewer edges than nodes, so no cycles;",source:"@site/docs/algorithm/graph.md",sourceDirName:"algorithm",slug:"/algorithm/graph",permalink:"/my-website/docs/algorithm/graph",draft:!1,unlisted:!1,editUrl:"https://github.com/lrchljw/my-website/tree/main/docs/algorithm/graph.md",tags:[],version:"current",frontMatter:{title:"Graph"},sidebar:"docSidebar",previous:{title:"Algorithm",permalink:"/my-website/docs/category/algorithm"},next:{title:"Concepts",permalink:"/my-website/docs/category/concepts"}},c={},o=[{value:"Data Structures",id:"data-structures",level:2},{value:"Outgoing edge array (Preferred)",id:"outgoing-edge-array-preferred",level:3},{value:"Adjacency matrix",id:"adjacency-matrix",level:3},{value:"Adjacency linked list",id:"adjacency-linked-list",level:3},{value:"Undirected graph",id:"undirected-graph",level:3},{value:"Topological Sort",id:"topological-sort",level:2},{value:"References",id:"references",level:2}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Tree: N nodes, N-1 edges, fewer edges than nodes, so no cycles;"}),"\n",(0,r.jsx)(n.li,{children:"Graph: N nodes, M edges, cycles may exist (check for duplicates when searching); a tree is a specialized graph."}),"\n",(0,r.jsx)(n.li,{children:"Node: state, Edge: change of state; use this idea to construct a graph."}),"\n",(0,r.jsx)(n.li,{children:"inEdge / inDeg: In-degree (incoming edges), in a directed graph, the number of edges pointing to this node; out-degree (outgoing edges), in a directed graph, the number of edges from this node to other nodes."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"data-structures",children:"Data Structures"}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TD;\n    1--\x3e2;\n    1--\x3e3\n    3--\x3e2\n    3--\x3e4"}),"\n",(0,r.jsx)(n.h3,{id:"outgoing-edge-array-preferred",children:"Outgoing edge array (Preferred)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vector<vector<int>>"}),": ",(0,r.jsx)(n.code,{children:"vector<int>"})," is a list of nodes connected to the current node."]}),"\n",(0,r.jsx)(n.li,{children:"Space complexity: O(n + m), n is the number of nodes, m is the number of edges."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1: [2, 3]\n2: []\n3: [2, 4]\n4: []\n"})}),"\n",(0,r.jsx)(n.h3,{id:"adjacency-matrix",children:"Adjacency matrix"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Disadvantage: When there are many nodes and few edges (sparse graph), it is very space-consuming. For N nodes, the matrix consumes N^2 space."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"  1 2 3 4\n1 0 1 1 0\n2 0 0 0 0\n3 0 1 0 1\n4 0 0 0 0\n"})}),"\n",(0,r.jsx)(n.h3,{id:"adjacency-linked-list",children:"Adjacency linked list"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Note: When building a linked list, inserting at the head of a singly linked list has a time complexity of O(1)."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1 -> 3 -> 2 -> null\n2 -> null\n3 -> 4 -> 2 -> null\n4 -> null\n"})}),"\n",(0,r.jsx)(n.h3,{id:"undirected-graph",children:"Undirected graph"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add two edges for each edge. e.g., ",(0,r.jsx)(n.code,{children:"a -> b, b -> a"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"topological-sort",children:"Topological Sort"}),"\n",(0,r.jsx)(n.p,{children:"Algorithm finds a topological order in O(m + n) time."}),"\n",(0,r.jsx)(n.p,{children:"Maintain the following information:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"count(w) = remaining number of incoming edges"}),"\n",(0,r.jsxs)(n.li,{children:["S = set of remaining nodes with no incoming edges","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Initialization: O(m + n) via single scan through graph."}),"\n",(0,r.jsx)(n.li,{children:"Update: to delete v"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"remove v from S"}),"\n",(0,r.jsx)(n.li,{children:"decrement count(w) for all edges from v to w;\nand add w to S if count(w) hits 0"}),"\n",(0,r.jsx)(n.li,{children:"this is O(1) per edge"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/03Graphs.pdf",children:"Graphs.PDF from cs.princeton.edu"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>l});var r=i(6540);const t={},s=r.createContext(t);function d(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);