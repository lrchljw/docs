"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[554],{6133:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>t,metadata:()=>l,toc:()=>c});var r=i(4848),s=i(8453);const t={title:"Graph"},d=void 0,l={id:"dsa/graph",title:"Graph",description:"- Tree (Connected Acyclic Graph): N nodes, N-1 edges, fewer edges than nodes, so no cycles;",source:"@site/docs/dsa/graph.md",sourceDirName:"dsa",slug:"/dsa/graph",permalink:"/my-website/docs/dsa/graph",draft:!1,unlisted:!1,editUrl:"https://github.com/lrchljw/my-website/tree/main/docs/dsa/graph.md",tags:[],version:"current",frontMatter:{title:"Graph"},sidebar:"docSidebar",previous:{title:"Data Structure & Algorithm",permalink:"/my-website/docs/category/data-structure--algorithm"},next:{title:"IDE",permalink:"/my-website/docs/category/ide"}},o={},c=[{value:"Data Structures",id:"data-structures",level:2},{value:"Outgoing edge array (Preferred)",id:"outgoing-edge-array-preferred",level:3},{value:"Adjacency matrix",id:"adjacency-matrix",level:3},{value:"Adjacency linked list",id:"adjacency-linked-list",level:3},{value:"Undirected graph",id:"undirected-graph",level:3},{value:"Topological Sort",id:"topological-sort",level:2},{value:"BFS",id:"bfs",level:3},{value:"Use Cases",id:"use-cases",level:3},{value:"References",id:"references",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Tree (Connected Acyclic Graph): N nodes, N-1 edges, fewer edges than nodes, so no cycles;","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"A tree is a specialized graph."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Graph: N nodes, M edges, cycles may exist","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Check for visited nodes to avoid infinite loops."}),"\n",(0,r.jsx)(n.li,{children:"No root node."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"Node: state, Edge: change of state; use this idea to construct a graph."})}),"\n",(0,r.jsx)(n.li,{children:"inEdge / inDeg: In-degree (incoming edges), in a directed graph, the number of edges pointing to this node; out-degree (outgoing edges), in a directed graph, the number of edges from this node to other nodes."}),"\n",(0,r.jsx)(n.li,{children:"Layer of a node: the shortest path from the root node to the current node."}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Directed Acyclic Graph"})," (DAG): A directed graph with no cycles.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Task scheduling, topological sort."}),"\n",(0,r.jsx)(n.li,{children:"Mining: finding the longest path in a DAG."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsx)(n.p,{children:"Draw a graph makes it easier to understand the problem."})}),"\n",(0,r.jsx)(n.h2,{id:"data-structures",children:"Data Structures"}),"\n",(0,r.jsx)(n.mermaid,{value:"graph TD;\n    1--\x3e2;\n    1--\x3e3\n    3--\x3e2\n    3--\x3e4"}),"\n",(0,r.jsx)(n.h3,{id:"outgoing-edge-array-preferred",children:"Outgoing edge array (Preferred)"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"vector<vector<int>>"}),": ",(0,r.jsx)(n.code,{children:"vector<int>"})," is a list of nodes connected to the current node."]}),"\n",(0,r.jsx)(n.li,{children:"Space complexity: O(n + m), n is the number of nodes, m is the number of edges."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1: [2, 3]\n2: []\n3: [2, 4]\n4: []\n"})}),"\n",(0,r.jsx)(n.h3,{id:"adjacency-matrix",children:"Adjacency matrix"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Disadvantage: When there are many nodes and few edges (sparse graph), it is very space-consuming. For N nodes, the matrix consumes N^2 space."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"  1 2 3 4\n1 0 1 1 0\n2 0 0 0 0\n3 0 1 0 1\n4 0 0 0 0\n"})}),"\n",(0,r.jsx)(n.h3,{id:"adjacency-linked-list",children:"Adjacency linked list"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Note: When building a linked list, inserting at the head of a singly linked list has a time complexity of O(1)."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"1 -> 3 -> 2 -> null\n2 -> null\n3 -> 4 -> 2 -> null\n4 -> null\n"})}),"\n",(0,r.jsx)(n.h3,{id:"undirected-graph",children:"Undirected graph"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Add two edges for each edge. e.g., ",(0,r.jsx)(n.code,{children:"a -> b, b -> a"})]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"topological-sort",children:"Topological Sort"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Sort a Directed Acyclic Graph (DAG) such that for every node ",(0,r.jsx)(n.code,{children:"v"}),",","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["all the nodes that ",(0,r.jsx)(n.code,{children:"v"})," points to are to the right of ",(0,r.jsx)(n.code,{children:"v"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:["all the nodes that point to ",(0,r.jsx)(n.code,{children:"v"})," are to the left of ",(0,r.jsx)(n.code,{children:"v"}),"."]}),"\n",(0,r.jsx)(n.li,{children:"e.g. v -> a, v -> b, c -> v, the topological order can be c -> v -> a -> b, or c -> v -> b -> a."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["Sort result is not unique.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Imagine multiple tasks that has no dependency, the order of these tasks can be arbitrary."}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Algorithm finds a topological order in O(m + n) time."}),"\n"]}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsx)(n.p,{children:"If the graph has a cycle, it cannot have a topological order."}),(0,r.jsx)(n.p,{children:"The reason is that a cycle means there is a circular dependency between nodes, which makes it impossible to determine which node should come first."}),(0,r.jsx)(n.p,{children:"Using the topological sort algorithm can not visit all nodes in the graph, beacause in-degree of some nodes will never be 0 so they will never be added to the queue."})]}),"\n",(0,r.jsx)(n.h3,{id:"bfs",children:"BFS"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Maintain the following information:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"count(w) = remaining number of incoming edges"}),"\n",(0,r.jsx)(n.li,{children:"S = set of remaining nodes with no incoming edges"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.li,{children:"Initialization: O(m + n) via single scan through graph."}),"\n",(0,r.jsxs)(n.li,{children:["Update: to delete v","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"remove v from S"}),"\n",(0,r.jsx)(n.li,{children:"decrement count(w) for all edges from v to w; and add w to S if count(w) hits 0"}),"\n",(0,r.jsx)(n.li,{children:"this is O(1) per edge"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"use-cases",children:"Use Cases"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Find the maximum depth of each node in a graph.","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Each node will enqueue when its in-degree is 0, and the max depth of a node add 1 to the max depth of its parent node."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/03Graphs.pdf",children:"Graphs.PDF from cs.princeton.edu"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>l});var r=i(6540);const s={},t=r.createContext(s);function d(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);